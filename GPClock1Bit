library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity GPClock1Bit is
generic (TIMER: INTEGER); --FRECUENCIA DE NUESTROS RELOJES INDIVIDUALES
port (
    clk: in STD_LOGIC;
    rst: IN STD_LOGIC;
    Clk1Bit: out STD_LOGIC --La se√±al que va a cambiar segun el reloj dividido.
);
end GPClock1Bit;

architecture behav of GPClock1Bit is

    constant max_refresh_count: INTEGER := TIMER; 
    signal refresh_count: INTEGER range 0 to max_refresh_count;
    signal refresh_state: STD_LOGIC := '0';
	
begin

    gen_clock: process(clk, rst)
    begin
            
      IF (rst = '0') THEN
          refresh_count <= 0;
          refresh_state <= '0';
      ELSIF (clk'event and clk='1') then
            -- contador TIMER (Para cambiar las paredes de displays)
                if refresh_count < max_refresh_count then
                refresh_count <= refresh_count + 1;
                else
                  refresh_state <= not(refresh_state);
                  refresh_count <= 0; 
                end if; 
       END IF; 
        Clk1Bit <= refresh_state;
    end process; 
END behav;
