library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity Carretera is
  PORT( 
        rst, clk: IN std_logic;
        FlagIzqPos, FlagDerPos: OUT std_logic_vector(2 downto 0); --Definimos 4 salidas, dos para las dos posiciones de las paredes y otras dos para, dentro de cada posición, el ladoi izquierdo o derecho de cada pared.
        FlagIzqLado, FlagDerLado: OUT std_logic 
  );
end Carretera;

architecture Behavioral of Carretera is

COMPONENT ClockDisplay is
generic (TIMER: INTEGER); --FRECUENCIA DE NUESTROS RELOJES INDIVIDUALES;
port (
    clk: in STD_LOGIC;
    Selector: out STD_LOGIC_VECTOR (2 DOWNTO 0) --La señal que va a cambiar segun el reloj dividido.
);
END COMPONENT;

SIGNAL SFlagIzqPos, SFlagDerPos: std_logic_vector(2 downto 0);
SIGNAL SFlagIzqLado, SFlagDerLado: std_logic; 
SIGNAL SelectorD: STD_LOGIC_VECTOR(2 DOWNTO 0);
BEGIN

inst_clkparedes: ClockDisplay
                 GENERIC MAP (N => 3000000000)
                 PORT MAP( Selector => SelectorD); 
PROCESS (clk, rst)
BEGIN

IF rst='0' THEN --Con el reset regresamos el reset a la primera posición definida
--Primera iteración

FlagDerPos <= "000";
FlagDerLado <= '1';
FlagIzqPos <= "010";
FlagIzqLado <= '0';

--WAIT for 3000 ms;

ELSIF rst/='1' THEN
      CASE SelectorD IS --case para mover automáticamente las paredes
          WHEN "000" =>
                FlagDerPos <= "000";
                FlagDerLado <= '1';
                FlagIzqPos <= "010";
                FlagIzqLado <= '0';
          WHEN "001" =>
                FlagDerPos <= "000";
                FlagDerLado <= '0';
                FlagIzqPos <= "011";
                FlagIzqLado <= '1';
          WHEN "010" =>
                FlagDerPos <= "001";
                FlagDerLado <= '1';
                FlagIzqPos <= "011";
                FlagIzqLado <= '0';
          WHEN "011" =>
                FlagDerPos <= "001";
                FlagDerLado <= '0';
                FlagIzqPos <= "100";
                FlagIzqLado <= '1';
          WHEN "100" =>
                FlagDerPos <= "010";
                FlagDerLado <= '1';
                FlagIzqPos <= "100";
                FlagIzqLado <= '0';
          WHEN "101" =>
                FlagDerPos <= "010";
                FlagDerLado <= '0';
                FlagIzqPos <= "101";
                FlagIzqLado <= '1';
          WHEN "110" =>
                FlagDerPos <= "011";
                FlagDerLado <= '1';
                FlagIzqPos <= "101";
                FlagIzqLado <= '0';
          WHEN "111" =>
                FlagDerPos <= "011";
                FlagDerLado <= '0';
                FlagIzqPos <= "110";
                FlagIzqLado <= '1';

--WAIT for 3000 ms;

----Novena iteración

--FlagDerPos <= "100";
--FlagDerLado <= '1';
--FlagIzqPos <= "110";
--FlagIzqLado <= '0';

--WAIT for 3000 ms;

----Décima iteración

--FlagDerPos <= "100";
--FlagDerLado <= '0';
--FlagIzqPos <= "111";
--FlagIzqLado <= '1';

--WAIT for 3000 ms;

----Undécima iteración

--FlagDerPos <= "101";
--FlagDerLado <= '1';
--FlagIzqPos <= "111";
--FlagIzqLado <= '0';

--WAIT for 3000 ms;

END IF;
END PROCESS;

--FlagDerPos <= SFlagDerPos;
--FlagDerPos <= SFlagDerPos;
--FlagDerPos <= SFlagDerPos;
